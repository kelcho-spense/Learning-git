<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-05-05T15:09:18.1520285"><title>Advanced Git Operations | Git & Github</title><script type="application/json" id="virtual-toc-data">[{"id":"feature-branch-workflow","level":0,"title":"Feature Branch workflow","anchor":"#feature-branch-workflow"},{"id":"gitflow-workflow","level":0,"title":"Gitflow workflow","anchor":"#gitflow-workflow"},{"id":"forking-workflow","level":0,"title":"Forking workflow","anchor":"#forking-workflow"},{"id":"git-rebasing","level":0,"title":"Git Rebasing","anchor":"#git-rebasing"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Advanced Git Operations | Git & Github"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Git &amp; Github Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//v1/advanced-git-operations.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Advanced Git Operations | Git & Github"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//v1/advanced-git-operations.html#webpage",
    "url": "writerside-documentation//v1/advanced-git-operations.html",
    "name": "Advanced Git Operations | Git & Github",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Git & Github Help"
}</script><!-- End Schema.org --></head><body data-id="Advanced-Git-Operations" data-main-title="Advanced Git Operations" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="README.md|VERSION CONTROL"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Git &amp; Github v1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Advanced-Git-Operations" id="Advanced-Git-Operations.md">Advanced Git Operations</h1><p id="s37ere_3">Have you gotten accustomed to the basics of <code class="code" id="s37ere_9">git</code>, but the advanced concepts make you <span class="emphasis" id="s37ere_10">scratch your head</span>?</p><figure id="s37ere_4"><img alt="hard-things" src="images/scratch-head.webp" title="hard-things" width="426" height="324"></figure><section class="chapter"><h2 id="feature-branch-workflow" data-toc="feature-branch-workflow">Feature Branch workflow</h2><p id="s37ere_11">The core idea behind the Feature Branch Workflow is that all feature development should take place in a dedicated branch instead of the <code class="code" id="s37ere_27">main</code> branch. This encapsulation makes it easy for multiple developers to work on a particular feature without disturbing the main codebase. It also means the <code class="code" id="s37ere_28">main</code> branch will never contain broken code, which is a huge advantage for continuous integration environments.</p><section class="chapter"><h3 id="start-with-the-main-branch" data-toc="start-with-the-main-branch">Start with the main branch</h3><p id="s37ere_29">All feature branches are created off the latest code state of a project. This guide assumes this is maintained and updated in the <code class="code" id="s37ere_31">main</code> branch.</p><div class="code-block" data-lang="css">
git checkout main
git fetch origin 
git reset --hard origin/main
</div></section><section class="chapter"><h3 id="create-the-repository" data-toc="create-the-repository">Create the repository</h3><p id="s37ere_32">This switches the repo to the <code class="code" id="s37ere_33">main</code> branch, pulls the latest commits and resets the repo's local copy of <code class="code" id="s37ere_34">main</code> to match the latest version.</p></section><section class="chapter"><h3 id="create-a-new-branch" data-toc="create-a-new-branch">Create a new-branch</h3><p id="s37ere_35">Use a separate branch for each feature or issue you work on. After creating a branch, check it out locally so that any changes you make will be on that branch.</p><div class="code-block" data-lang="css">
git checkout -b new-feature
</div><p id="s37ere_37">This checks out a branch called new-feature based on <code class="code" id="s37ere_38">main</code>, and the -b flag tells Git to create the branch if it doesn&rsquo;t already exist.</p></section><section class="chapter"><h3 id="update-add-commit-and-push-changes" data-toc="update-add-commit-and-push-changes">Update, add, commit, and push changes</h3><p id="s37ere_39">On this branch, edit, stage, and commit changes in the usual fashion, building up the feature with as many commits as necessary. Work on the feature and make commits like you would any time you use Git. When ready, push your commits, updating the feature branch on Bitbucket.</p><div class="code-block" data-lang="markup">
git status
git add &lt;some-file&gt;
git commit
</div></section><section class="chapter"><h3 id="push-feature-branch-to-remote" data-toc="push-feature-branch-to-remote">Push feature branch to remote</h3><p id="s37ere_41">It&rsquo;s a good idea to push the feature branch up to the central repository. This serves as a convenient backup, when collaborating with other developers, this would give them access to view commits to the new branch.</p><div class="code-block" data-lang="javascript">
git push -u origin new-feature
</div><p id="s37ere_43">This command pushes new-feature to the central repository (origin), and the -u flag adds it as a remote tracking branch. After setting up the tracking branch, <code class="code" id="s37ere_44">git push</code> can be invoked without any parameters to automatically push the new-feature branch to the central repository. To get feedback on the new feature branch, create a pull request in a repository management solution like bitbucket cloud or GitHub. From there, you can add reviewers and make sure everything is good to go before merging.</p></section><section class="chapter"><h3 id="resolve-feedback" data-toc="resolve-feedback">Resolve feedback</h3><p id="s37ere_45">Now teammates comment and approve the pushed commits. Resolve their comments locally, commit, and push the suggested changes to Bitbucket. Your updates appear in the pull request.</p></section><section class="chapter"><h3 id="merge-your-pull-request" data-toc="merge-your-pull-request">Merge your pull request</h3><p id="s37ere_46">Before you merge, you may have to resolve merge conflicts if others have made changes to the repo. When your pull request is approved and conflict-free, you can add your code to the <code class="code" id="s37ere_47">main</code> branch. Merge from the pull request in Bitbucket.</p></section><section class="chapter"><h3 id="pull-requests" data-toc="pull-requests">Pull requests</h3><p id="s37ere_48">Once a pull request is accepted, the actual act of publishing a feature is much the same as in the Centralized Workflow. First, you need to make sure your local <code class="code" id="s37ere_50">main</code> is synchronized with the upstream <code class="code" id="s37ere_51">main</code>. Then, you merge the feature branch into <code class="code" id="s37ere_52">main</code> and push the updated <code class="code" id="s37ere_53">main</code> back to the central repository.</p><p id="s37ere_49">Pull requests can be facilitated by source code management solutions like Bitbucket Cloud.</p></section><section class="chapter"><h3 id="example-feature-branching-workflow" data-toc="example-feature-branching-workflow">Example feature branching workflow</h3><p id="s37ere_55">The following is an example of the type of scenario in which a feature branching workflow is used. The scenario is that of a team doing code review around on a new feature pull request. This is one example of the many purposes this model can be used for.</p></section><section class="chapter"><h3 id="mary-begins-a-new-feature" data-toc="mary-begins-a-new-feature">Mary begins a new feature</h3><figure id="s37ere_56"><img alt="Feature branch illustration" src="https://wac-cdn.atlassian.com/dam/jcr:223f5106-2191-4450-8916-e5c80d7d907a/02.svg?cdnVersion=2688" title="Feature branch illustration"></figure><p id="s37ere_57">Before she starts developing a feature, Mary needs an isolated branch to work on. She can request a new branch with the following command:</p><div class="code-block" data-lang="css">
git checkout -b marys-feature main
</div><p id="s37ere_59">This checks out a branch called <code class="code" id="s37ere_61">marys-feature</code> based on <code class="code" id="s37ere_62">main,</code> and the -b flag tells Git to create the branch if it doesn&rsquo;t already exist. On this branch, Mary edits, stages, and commits changes in the usual fashion, building up her feature with as many commits as necessary:</p><div class="code-block" data-lang="markup">
git status
git add &lt;some-file&gt;
git commit
</div></section><section class="chapter"><h3 id="mary-goes-to-lunch" data-toc="mary-goes-to-lunch">Mary goes to lunch</h3><figure id="s37ere_63"><img alt="Push to central repository" src="https://wac-cdn.atlassian.com/dam/jcr:e2c88c1b-fb28-46a3-93be-c1c45f86bd1c/03%20(1).svg?cdnVersion=2688" title="Push to central repository"></figure><p id="s37ere_64">Mary adds a few commits to her feature over the course of the morning. Before she leaves for lunch, it&rsquo;s a good idea to push her feature branch up to the central repository. This serves as a convenient backup, but if Mary was collaborating with other developers, this would also give them access to her initial commits.</p><div class="code-block" data-lang="bash">
git push -u origin marys-feature
</div><p id="s37ere_66">This command pushes <code class="code" id="s37ere_67">marys-feature</code> to the central repository (origin), and the -u flag adds it as a remote tracking branch. After setting up the tracking branch, Mary can call <code class="code" id="s37ere_68">git push</code> without any parameters to push her feature.</p></section><section class="chapter"><h3 id="mary-finishes-her-feature" data-toc="mary-finishes-her-feature">Mary finishes her feature</h3><figure id="s37ere_69"><img alt="Pull request" src="https://wac-cdn.atlassian.com/dam/jcr:d0c471b4-61c8-4005-86bc-904d894e391b/04.svg?cdnVersion=2688" title="Pull request"></figure><p id="s37ere_70">When Mary gets back from lunch, she completes her feature. Before merging it into <code class="code" id="s37ere_73">main</code>, she needs to file a pull request letting the rest of the team know she's done. But first, she should make sure the central repository has her most recent commits:</p><div class="code-block" data-lang="bash">
git push
</div><p id="s37ere_72">Then, she files the pull request in her Git GUI asking to merge <code class="code" id="s37ere_74">marys-feature</code> into <code class="code" id="s37ere_75">main</code>, and team members will be notified automatically. The great thing about pull requests is that they show comments right next to their related commits, so it's easy to ask questions about specific changesets.</p></section><section class="chapter"><h3 id="bill-receives-the-pull-request" data-toc="bill-receives-the-pull-request">Bill receives the pull request</h3><figure id="s37ere_76"><img alt="Review pull request illustration" src="https://wac-cdn.atlassian.com/dam/jcr:2119c2a3-7dff-43ad-bf98-77672d93242f/05%20(1).svg?cdnVersion=2688" title="Review pull request illustration"></figure><p id="s37ere_77">Bill gets the pull request and takes a look at <code class="code" id="s37ere_78">marys-feature.</code> He decides he wants to make a few changes before integrating it into the official project, and he and Mary have some back-and-forth via the pull request.</p></section><section class="chapter"><h3 id="mary-makes-the-changes" data-toc="mary-makes-the-changes">Mary makes the changes</h3><figure id="s37ere_79"><img alt="Pull request revisions" src="https://wac-cdn.atlassian.com/dam/jcr:1c466900-dffa-4912-8764-79943755dbf9/06%20(1).svg?cdnVersion=2688" title="Pull request revisions"></figure><p id="s37ere_80">To make the changes, Mary uses the exact same process as she did to create the first iteration of her feature. She edits, stages, commits, and pushes updates to the central repository. All her activity shows up in the pull request, and Bill can still make comments along the way.</p><p id="s37ere_81">If he wanted, Bill could pull <code class="code" id="s37ere_82">marys-feature</code> into his local repository and work on it on his own. Any commits he added would also show up in the pull request.</p></section><section class="chapter"><h3 id="mary-publishes-her-feature" data-toc="mary-publishes-her-feature">Mary publishes her feature</h3><figure id="s37ere_83"><img alt="Publishing feature" src="https://wac-cdn.atlassian.com/dam/jcr:09308632-38a3-4637-bba2-af2110629d56/07.svg?cdnVersion=2688" title="Publishing feature"></figure><p id="s37ere_84">Once Bill is ready to accept the pull request, someone needs to merge the feature into the stable project (this can be done by either Bill or Mary):</p><div class="code-block" data-lang="css">
git checkout main
git pull
git pull origin marys-feature
git push
</div><p id="s37ere_86">This process often results in a merge commit. Some developers like this because it&rsquo;s like a symbolic joining of the feature with the rest of the code base. But, if you&rsquo;re partial to a linear history, it&rsquo;s possible to rebase the feature onto the tip of <code class="code" id="s37ere_91">main</code> before executing the merge, resulting in a fast-forward merge.</p><p id="s37ere_87">Some GUI&rsquo;s will automate the pull request acceptance process by running all of these commands just by clicking an &ldquo;Accept&rdquo; button. If yours doesn&rsquo;t, it should at least be able to automatically close the pull request when the feature branch gets merged into <code class="code" id="s37ere_92">main.</code></p><p id="s37ere_88">Meanwhile, John is doing the exact same thing.</p><p id="s37ere_89">While Mary and Bill are working on marys-feature and discussing it in her pull request, John is doing the exact same thing with his own feature branch. By isolating features into separate branches, everybody can work independently, yet it&rsquo;s still trivial to share changes with other developers when necessary.</p></section></section><section class="chapter"><h2 id="gitflow-workflow" data-toc="gitflow-workflow">Gitflow workflow</h2><figure id="s37ere_93"><img alt="1746388779271" src="images/1746388779271.png" title="1746388779271" width="3167" height="1095"></figure><p id="s37ere_94">Gitflow is an alternative Git branching model that involves the use of feature branches and multiple primary branches. It was first published and made popular by Vincent Driessen at nvie. Compared to trunk-based development, Gitflow has numerous, longer-lived branches and larger commits</p><section class="chapter"><h3 id="how-it-works_1" data-toc="how-it-works_1">How it works</h3><figure id="s37ere_100"><img alt="Git workflow" src="https://wac-cdn.atlassian.com/dam/jcr:a13c18d6-94f3-4fc4-84fb-2b8f1b2fd339/01%20How%20it%20works.svg?cdnVersion=2688" title="Git workflow"></figure></section><section class="chapter"><h3 id="develop-and-main-branches" data-toc="develop-and-main-branches">Develop and main branches</h3><p id="s37ere_101">Instead of a single <code class="code" id="s37ere_107">main</code> branch, this workflow uses two branches to record the history of the project. The <code class="code" id="s37ere_108">main</code> branch stores the official release history, and the <code class="code" id="s37ere_109">develop</code> branch serves as an integration branch for features. It's also convenient to tag all commits in the <code class="code" id="s37ere_110">main</code> branch with a version number.</p><p id="s37ere_102">The first step is to complement the default <code class="code" id="s37ere_111">main</code> with a <code class="code" id="s37ere_112">develop</code> branch. A simple way to do this is for one developer to create an empty <code class="code" id="s37ere_113">develop</code> branch locally and push it to the server:</p><div class="code-block" data-lang="bash">
git branch develop
git push -u origin develop
</div><p id="s37ere_104">This branch will contain the complete history of the project, whereas <code class="code" id="s37ere_114">main</code> will contain an abridged version. Other developers should now clone the central repository and create a tracking branch for <code class="code" id="s37ere_115">develop.</code></p><p id="s37ere_105">When using the git-flow extension library, executing <code class="code" id="s37ere_116">git flow init</code> on an existing repo will create the <code class="code" id="s37ere_117">develop</code> branch:</p><div class="code-block" data-lang="javascript">
$ git flow init


Initialized empty Git repository in ~/project/.git/
No branches exist yet. Base branches must be created now.
Branch name for production releases: [main]
Branch name for &quot;next release&quot; development: [develop]


How to name your supporting branch prefixes?
Feature branches? [feature/]
Release branches? [release/]
Hotfix branches? [hotfix/]
Support branches? [support/]
Version tag prefix? []


$ git branch
* develop
 main
</div></section><section class="chapter"><h3 id="feature-branches" data-toc="feature-branches">Feature branches</h3><section class="chapter"><h4 id="step-1-create-the-repository" data-toc="step-1-create-the-repository">Step 1. Create the repository</h4><p id="s37ere_122">Each new feature should reside in its own branch, which can be <a href="https://www.atlassian.com/git/tutorials/syncing/git-push" id="s37ere_126" data-external="true" rel="noopener noreferrer" target="_blank">pushed to the central repository</a> for backup/collaboration. But, instead of branching off of <code class="code" id="s37ere_127">main</code>, <code class="code" id="s37ere_128">feature</code> branches use <code class="code" id="s37ere_129">develop</code> as their parent branch. When a feature is complete, it gets <a href="https://www.atlassian.com/git/tutorials/using-branches/git-merge" id="s37ere_130" data-external="true" rel="noopener noreferrer" target="_blank">merged back into develop</a>. Features should never interact directly with <code class="code" id="s37ere_131">main</code>.</p><figure id="s37ere_123"><img alt="Git workflow - feature branches" src="https://wac-cdn.atlassian.com/dam/jcr:34c86360-8dea-4be4-92f7-6597d4d5bfae/02%20Feature%20branches.svg?cdnVersion=2688" title="Git workflow - feature branches"></figure><p id="s37ere_124">Note that <code class="code" id="s37ere_132">feature</code> branches combined with the <code class="code" id="s37ere_133">develop</code> branch is, for all intents and purposes, the Feature Branch Workflow. But, the Gitflow workflow doesn&rsquo;t stop there.</p><p id="s37ere_125"><code class="code" id="s37ere_134">Feature</code> branches are generally created off to the latest <code class="code" id="s37ere_135">develop</code> branch.</p></section><section class="chapter"><h4 id="creating-a-feature-branch" data-toc="creating-a-feature-branch">Creating a feature branch</h4><p id="s37ere_136">Without the git-flow extensions:</p><div class="code-block" data-lang="css">
git checkout develop
git checkout -b feature_branch
</div><p id="s37ere_138">When using the git-flow extension:</p><div class="code-block" data-lang="css">
git flow feature start feature_branch
</div><p id="s37ere_140">Continue your work and use Git like you normally would.</p></section><section class="chapter"><h4 id="finishing-a-feature-branch" data-toc="finishing-a-feature-branch">Finishing a feature branch</h4><p id="s37ere_141">When you&rsquo;re done with the development work on the feature, the next step is to merge the <code class="code" id="s37ere_146">feature_branch</code> into <code class="code" id="s37ere_147">develop</code>.</p><p id="s37ere_142">Without the git-flow extensions:</p><div class="code-block" data-lang="bash">
git checkout develop
git merge feature_branch
</div><p id="s37ere_144">Using the git-flow extensions:</p><div class="code-block" data-lang="css">
git flow feature finish feature_branch
</div></section></section><section class="chapter"><h3 id="release-branches" data-toc="release-branches">Release branches</h3><figure id="s37ere_149"><img alt="Git workflow - release branches" src="https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg?cdnVersion=2688" title="Git workflow - release branches"></figure><p id="s37ere_150">Once <code class="code" id="s37ere_163">develop</code> has acquired enough features for a release (or a predetermined release date is approaching), you fork a <code class="code" id="s37ere_164">release</code> branch off of <code class="code" id="s37ere_165">develop</code>. Creating this branch starts the next release cycle, so no new features can be added after this point&mdash;only bug fixes, documentation generation, and other release-oriented tasks should go in this branch. Once it's ready to ship, the <code class="code" id="s37ere_166">release</code> branch gets merged into <code class="code" id="s37ere_167">main</code> and tagged with a version number. In addition, it should be merged back into <code class="code" id="s37ere_168">develop</code>, which may have progressed since the release was initiated.</p><p id="s37ere_151">Using a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development (e.g., it's easy to say, &ldquo;This week we're preparing for version 4.0,&rdquo; and to actually see it in the structure of the repository).</p><p id="s37ere_152">Making <code class="code" id="s37ere_169">release</code> branches is another straightforward branching operation. Like <code class="code" id="s37ere_170">feature</code> branches, <code class="code" id="s37ere_171">release</code> branches are based on the <code class="code" id="s37ere_172">develop</code> branch. A new <code class="code" id="s37ere_173">release</code> branch can be created using the following methods.</p><p id="s37ere_153">Without the git-flow extensions:</p><div class="code-block" data-lang="css">
git checkout develop
git checkout -b release/0.1.0
</div><p id="s37ere_155">When using the git-flow extensions:</p><div class="code-block" data-lang="javascript">
$ git flow release start 0.1.0
Switched to a new branch 'release/0.1.0'
</div><p id="s37ere_157">Once the release is ready to ship, it will get merged it into <code class="code" id="s37ere_174">main</code> and <code class="code" id="s37ere_175">develop</code>, then the <code class="code" id="s37ere_176">release</code> branch will be deleted. It&rsquo;s important to merge back into <code class="code" id="s37ere_177">develop</code> because critical updates may have been added to the <code class="code" id="s37ere_178">release</code> branch and they need to be accessible to new features. If your organization stresses code review, this would be an ideal place for a pull request.</p><p id="s37ere_158">To finish a <code class="code" id="s37ere_179">release</code> branch, use the following methods:</p><p id="s37ere_159">Without the git-flow extensions:</p><div class="code-block" data-lang="css">
git checkout main
git merge release/0.1.0
</div><p id="s37ere_161">Or with the git-flow extension:</p><div class="code-block" data-lang="bash">
git flow release finish '0.1.0'
</div></section><section class="chapter"><h3 id="hotfix-branches" data-toc="hotfix-branches">Hotfix branches</h3><figure id="s37ere_181"><img alt="Hotfix branch within git workflow" src="https://wac-cdn.atlassian.com/dam/jcr:cc0b526e-adb7-4d45-874e-9bcea9898b4a/04%20Hotfix%20branches.svg?cdnVersion=2688" title="Hotfix branch within git workflow"></figure><p id="s37ere_182">Maintenance or <code class="code" id="s37ere_191">&ldquo;hotfix&rdquo;</code> branches are used to quickly patch production releases. <code class="code" id="s37ere_192">Hotfix</code> branches are a lot like <code class="code" id="s37ere_193">release</code> branches and <code class="code" id="s37ere_194">feature</code> branches except they're based on <code class="code" id="s37ere_195">main</code> instead of <code class="code" id="s37ere_196">develop</code>. This is the only branch that should fork directly off of <code class="code" id="s37ere_197">main</code>. As soon as the fix is complete, it should be merged into both <code class="code" id="s37ere_198">main</code> and <code class="code" id="s37ere_199">develop</code> (or the current <code class="code" id="s37ere_200">release</code> branch), and <code class="code" id="s37ere_201">main</code> should be tagged with an updated version number.</p><p id="s37ere_183">Having a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle. You can think of maintenance branches as ad hoc <code class="code" id="s37ere_202">release</code> branches that work directly with <code class="code" id="s37ere_203">main</code>. A <code class="code" id="s37ere_204">hotfix</code> branch can be created using the following methods:</p><p id="s37ere_184">Without the git-flow extensions:</p><div class="code-block" data-lang="css">
git checkout main
git checkout -b hotfix_branch
</div><p id="s37ere_186">When using the git-flow extensions:</p><div class="code-block" data-lang="scss">
$ git flow hotfix start hotfix_branch
</div><p id="s37ere_188">Similar to finishing a <code class="code" id="s37ere_205">release</code> branch, a <code class="code" id="s37ere_206">hotfix</code> branch gets merged into both <code class="code" id="s37ere_207">main</code> and <code class="code" id="s37ere_208">develop.</code></p><div class="code-block" data-lang="css">
git checkout main
git merge hotfix_branch
git checkout develop
git merge hotfix_branch
git branch -D hotfix_branch
</div><div class="code-block" data-lang="scss">
$ git flow hotfix finish hotfix_branch
</div></section></section><section class="chapter"><h2 id="forking-workflow" data-toc="forking-workflow">Forking workflow</h2><p id="s37ere_209">The Forking Workflow is fundamentally different than other popular Git workflows. Instead of using a single server-side repository to act as the &ldquo;central&rdquo; codebase, it gives every developer their own server-side repository. This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one. The Forking Workflow is most often seen in public open source projects.</p><section class="chapter"><h3 id="how-it-works" data-toc="how-it-works">How it works</h3><ol class="list _decimal" id="s37ere_212" type="1"><li class="list__item" id="s37ere_214"><p id="s37ere_223">A developer 'forks' an 'official' server-side repository. This creates their own server-side copy.</p></li><li class="list__item" id="s37ere_215"><p id="s37ere_224">The new server-side copy is cloned to their local system.</p></li><li class="list__item" id="s37ere_216"><p id="s37ere_225">A Git remote path for the 'official' repository is added to the local clone.</p></li><li class="list__item" id="s37ere_217"><p id="s37ere_226">A new local feature branch is created.</p></li><li class="list__item" id="s37ere_218"><p id="s37ere_227">The developer makes changes on the new branch.</p></li><li class="list__item" id="s37ere_219"><p id="s37ere_228">New commits are created for the changes.</p></li><li class="list__item" id="s37ere_220"><p id="s37ere_229">The branch gets pushed to the developer's own server-side copy.</p></li><li class="list__item" id="s37ere_221"><p id="s37ere_230">The developer opens a pull request from the new branch to the 'official' repository.</p></li><li class="list__item" id="s37ere_222"><p id="s37ere_231">The pull request gets approved for merge and is merged into the original server-side repository</p></li></ol><p id="s37ere_213">To integrate the feature into the official codebase, the maintainer pulls the contributor&rsquo;s changes into their local repository, checks to make sure it doesn&rsquo;t break the project, merges it into their local <code class="code" id="s37ere_232">main</code> branch, then pushes the <code class="code" id="s37ere_233">main</code> branch to the official repository on the server. The contribution is now part of the project, and other developers should pull from the official repository to synchronize their local repositories.</p></section><section class="chapter"><h3 id="forking-vs-cloning" data-toc="forking-vs-cloning">Forking vs cloning</h3><p id="s37ere_234">It's important to note that &quot;forked&quot; repositories and &quot;forking&quot; are not special operations. Forked repositories are created using the standard git clone command. Forked repositories are generally &quot;server-side clones&quot; and usually managed and hosted by a 3rd party Git service like Bitbucket. There is no unique Git command to create forked repositories. A clone operation is essentially a copy of a repository and its history.</p></section></section><section class="chapter"><h2 id="git-rebasing" data-toc="git-rebasing">Git Rebasing</h2><figure id="s37ere_235"><img alt="1746390511127" src="images/1746390511127.png" title="1746390511127" width="591" height="291"></figure><p id="s37ere_236">Git Rebase is a command used to move or combine a sequence of commits to a new base commit</p><section class="chapter"><h3 id="types-of-git-rebase" data-toc="types-of-git-rebase">Types of Git Rebase</h3><section class="chapter"><h4 id="1-interactive-rebase-git-rebase-i" data-toc="1-interactive-rebase-git-rebase-i"><span class="control" id="s37ere_251"><span class="control" id="s37ere_252">1. Interactive Rebase (git rebase -i)</span></span></h4><ul class="list _bullet" id="s37ere_246"><li class="list__item" id="s37ere_253"><p id="s37ere_257">This allows you to edit, squash, reorder, or delete commits in your branch. It gives you full control over the commit history, making it useful for cleaning up commit messages or combining multiple commits into one.</p></li><li class="list__item" id="s37ere_254"><p id="s37ere_258">It squashing commits to combine them into a single commit.</p></li><li class="list__item" id="s37ere_255"><p id="s37ere_259">Git rebase reordering commits to reflect a more logical flow.</p></li><li class="list__item" id="s37ere_256"><p id="s37ere_260">Editing commit messages before pushing them to a remote repository</p></li></ul><p id="s37ere_247"><span class="control" id="s37ere_261">Syntax:</span></p><div class="code-block" data-lang="bash">
git checkout branch_x
git rebase -i master
</div><p id="s37ere_249"><span class="control" id="s37ere_262">In this syntax</span>:</p><ul class="list _bullet" id="s37ere_250"><li class="list__item" id="s37ere_263"><p id="s37ere_264">This command lists all commits that are about to be moved and prompts you to edit or rearrange them based on your choices. It helps maintain a clean and structured project history.</p></li></ul></section><section class="chapter"><h4 id="2-non-interactive-rebase-standard-rebase" data-toc="2-non-interactive-rebase-standard-rebase"><span class="control" id="s37ere_271"><span class="control" id="s37ere_272">2. Non-Interactive Rebase (Standard Rebase)</span></span></h4><ul class="list _bullet" id="s37ere_266"><li class="list__item" id="s37ere_273"><p id="s37ere_275">This is the regular rebase command (git rebase <code class="code" id="s37ere_276">&lt;branch&gt;</code>), which simply applies your commits onto the target branch without allowing for manual intervention. It&rsquo;s ideal for straightforward rebasing where you don&rsquo;t need to modify or review individual commits.</p></li><li class="list__item" id="s37ere_274"><p id="s37ere_277">Updating your feature branch with the latest changes from the main branch.</p></li></ul><p id="s37ere_267"><span class="control" id="s37ere_278"><span class="control" id="s37ere_279">Syntax:</span></span></p><div class="code-block" data-lang="bash">
git checkout &lt;feature-branch&gt;
git rebase &lt;base-branch&gt;
</div><p id="s37ere_269"><span class="control" id="s37ere_280"><span class="control" id="s37ere_281">In this syntax:</span></span></p><ul class="list _bullet" id="s37ere_270"><li class="list__item" id="s37ere_282"><p id="s37ere_284"><code class="code" id="s37ere_285">&lt;feature-branch&gt;</code> is the branch with the changes you want to rebase.</p></li><li class="list__item" id="s37ere_283"><p id="s37ere_286"><code class="code" id="s37ere_287">&lt;base-branch&gt;</code> is the branch you want to rebase your changes onto, typically main or master.</p></li></ul></section></section><section class="chapter"><h3 id="when-to-use-git-rebase" data-toc="when-to-use-git-rebase">When to Use Git Rebase</h3><p id="s37ere_288">You can use git rebase in the following situations:</p><ul class="list _bullet" id="s37ere_289"><li class="list__item" id="s37ere_291"><p id="s37ere_294"><span class="control" id="s37ere_295"><span class="control" id="s37ere_296">Clean up commit history:</span></span> If you&rsquo;ve made multiple small commits or fixes that you want to combine into one commit for a cleaner history.</p></li><li class="list__item" id="s37ere_292"><p id="s37ere_297"><span class="control" id="s37ere_298"><span class="control" id="s37ere_299">Stay up-to-date with the base branch</span></span>: If you&rsquo;re working on a feature branch and want to incorporate changes from the master branch into your branch without creating merge commits.</p></li><li class="list__item" id="s37ere_293"><p id="s37ere_300"><span class="control" id="s37ere_301"><span class="control" id="s37ere_302">Prepare a branch for merging:</span></span> Before merging a feature branch into the master branch, you can use rebase to make sure your branch&rsquo;s changes are applied on top of the latest master branch.</p></li></ul><figure id="s37ere_290"><img alt="1746390799863" src="images/1746390799863.png" title="1746390799863" width="700" height="461"></figure></section><section class="chapter"><h3 id="merging-vs-rebasing" data-toc="merging-vs-rebasing">Merging vs Rebasing</h3><figure id="s37ere_303"><img alt="1746391592116" src="images/1746391592116.png" title="1746391592116" width="1148" height="720"></figure><div class="table-wrapper"><table class="wide" id="s37ere_304"><thead><tr class="ijRowHead" id="s37ere_305"><th id="s37ere_310"><p><span class="control" id="s37ere_312"><span class="control" id="s37ere_313">Git Rebase</span></span></p></th><th id="s37ere_311"><p><span class="control" id="s37ere_314"><span class="control" id="s37ere_315">Git Merge</span></span></p></th></tr></thead><tbody><tr id="s37ere_306"><td id="s37ere_316"><p>Rewrites commit history, leading to a cleaner, linear history.</p></td><td id="s37ere_317"><p>Keeps commit history as is, leading to a more complex, branching history.</p></td></tr><tr id="s37ere_307"><td id="s37ere_318"><p>No merge commit is created, making the history easier to follow.</p></td><td id="s37ere_319"><p>A merge commit is created, which can clutter the history.</p></td></tr><tr id="s37ere_308"><td id="s37ere_320"><p>Can be used to update a feature branch with the latest changes from the base branch.</p></td><td id="s37ere_321"><p>Often used to integrate feature branches into the main branch.</p></td></tr><tr id="s37ere_309"><td id="s37ere_322"><p>Best for cleaning up commit history before merging.</p></td><td id="s37ere_323"><p>Best for preserving history and when you want to maintain the exact sequence of events.</p></td></tr></tbody></table></div></section><section class="chapter"><h3 id="git-cherry-pick" data-toc="git-cherry-pick">Git Cherry pick</h3><figure id="s37ere_324"><img alt="1746391404822" src="images/1746391404822.png" title="1746391404822" width="990" height="394"></figure><p id="s37ere_325">git <span class="control" id="s37ere_333">cherry-pick</span> in git means choosing a commit from one branch and applying it to another branch. This is in contrast with other ways such as <span class="control" id="s37ere_334">merge</span> and <span class="control" id="s37ere_335">rebases</span> which normally apply many commits into another branch.</p><p id="s37ere_326">git cherry-pick is just like Rebasing an advanced concept and also a powerful command. It is mainly used if you don&rsquo;t want to merge the whole branch and you want some of the commits.</p><ul class="list _bullet" id="s37ere_327"><li class="list__item" id="s37ere_336"><p id="s37ere_337">Before cherry pick</p></li></ul><figure id="s37ere_328"><img alt="1746389939141" src="images/1746389939141.png" title="1746389939141" width="1000" height="500"></figure><ul class="list _bullet" id="s37ere_329"><li class="list__item" id="s37ere_338"><p id="s37ere_339">After Cherry pick</p></li></ul><figure id="s37ere_330"><img alt="1746389948319" src="images/1746389948319.png" title="1746389948319" width="1000" height="500"></figure><p id="s37ere_331">The command for Cherry-pick is as follows:</p><div class="code-block" data-lang="bash">
git cherry-pick&lt;commit-hash&gt;
</div></section><section class="chapter"><h3 id="some-important-use-cases-of-cherry-pick" data-toc="some-important-use-cases-of-cherry-pick">Some important Use Cases of Cherry-pick</h3><p id="s37ere_340">The following are some common applications of Cherry-Pick:</p><ol class="list _decimal" id="s37ere_341" type="1"><li class="list__item" id="s37ere_342"><p id="s37ere_346">If you by mistake make a commit in an incorrect branch, then using cherry-pick you can apply the required changes.</p></li><li class="list__item" id="s37ere_343"><p id="s37ere_347">Suppose when the same data structure is to be used by both the frontend and backend of a project. Then a developer can use cherry-pick to pick the commit and use it to his/her part of the project.</p></li><li class="list__item" id="s37ere_344"><p id="s37ere_348">At the point when a bug is found it is critical to convey a fix to end clients as fast as could be expected.</p></li><li class="list__item" id="s37ere_345"><p id="s37ere_349">Some of the time a component branch might go old and not get converged into the main branch and the request might get closed, but since git never loses those commits, it can be cherry-picked and it would be back.</p></li></ol></section><section class="chapter"><h3 id="how-to-use-cherry-pick" data-toc="how-to-use-cherry-pick">How to use cherry-pick?</h3><p id="s37ere_350">To demonstrate how to use <code class="code" id="s37ere_362">git cherry-pick</code> let us assume we have a repository with the following branch state:</p><div class="code-block" data-lang="css">
    a - b - c - d   Main
         \
           e - f - g Feature
</div><p id="s37ere_352"><code class="code" id="s37ere_363">git cherry-pick</code> usage is straight forward and can be executed like:</p><div class="code-block" data-lang="bash">
git cherry-pick commitSha
</div><p id="s37ere_354">In this example <code class="code" id="s37ere_364">commit</code> Sha is a commit reference. You can find a commit reference by using <code class="code" id="s37ere_365">git log</code>. In this example we have constructed lets say we wanted to use commit <code class="code" id="s37ere_366">f</code> in <code class="code" id="s37ere_367">main</code>. First we ensure that we are working on the <code class="code" id="s37ere_368">main</code> branch.</p><div class="code-block" data-lang="css">
git checkout main
</div><p id="s37ere_356">Then we execute the cherry-pick with the following command:</p><div class="code-block" data-lang="bash">
git cherry-pick f
</div><p id="s37ere_358">Once executed our Git history will look like:</p><div class="code-block" data-lang="css">
    a - b - c - d - f   Main
         \
           e - f - g Feature
</div><p id="s37ere_360">The f commit has been successfully picked into the main branch</p><p id="s37ere_361">Prepared with thanks by Kevin Comba</p></section></section><div class="last-modified">05 May 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="collaborating-workflows-syncing.html" class="navigation-links__prev">Collaborating workflows (syncing)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>